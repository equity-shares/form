{"version":3,"file":"solid-js_html.js","names":["html","i","delegateEvents","tag","childOptions"],"sources":["../../solid-js/html/dist/html.js"],"sourcesContent":["import { effect, style, insert, untrack, spread, createComponent, delegateEvents, classList, mergeProps, dynamicProperty, setAttribute, setAttributeNS, addEventListener, Aliases, getPropAlias, Properties, ChildProperties, DelegatedEvents, SVGElements, SVGNamespace } from 'solid-js/web';\n\nconst tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\nconst attrRE = /(?:\\s(?<boolean>[^/\\s><=]+?)(?=[\\s/>]))|(?:(?<name>\\S+?)(?:\\s*=\\s*(?:(['\"])(?<quotedValue>[\\s\\S]*?)\\3|(?<unquotedValue>[^\\s>]+))))/g;\nconst lookup = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  menuitem: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\nfunction parseTag(tag) {\n  const res = {\n    type: 'tag',\n    name: '',\n    voidElement: false,\n    attrs: [],\n    children: []\n  };\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/);\n  if (tagMatch) {\n    res.name = tagMatch[1];\n    if (lookup[tagMatch[1].toLowerCase()] || tag.charAt(tag.length - 2) === '/') {\n      res.voidElement = true;\n    }\n    if (res.name.startsWith('!--')) {\n      const endIndex = tag.indexOf('-->');\n      return {\n        type: 'comment',\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : ''\n      };\n    }\n  }\n  const reg = new RegExp(attrRE);\n  for (const match of tag.matchAll(reg)) {\n    if ((match[1] || match[2]).startsWith('use:')) {\n      res.attrs.push({\n        type: 'directive',\n        name: match[1] || match[2],\n        value: match[4] || match[5] || ''\n      });\n    } else {\n      res.attrs.push({\n        type: 'attr',\n        name: match[1] || match[2],\n        value: match[4] || match[5] || ''\n      });\n    }\n  }\n  return res;\n}\nfunction pushTextNode(list, html, start) {\n  const end = html.indexOf('<', start);\n  const content = html.slice(start, end === -1 ? undefined : end);\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: 'text',\n      content: content\n    });\n  }\n}\nfunction pushCommentNode(list, tag) {\n  const content = tag.replace('<!--', '').replace('-->', '');\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: 'comment',\n      content: content\n    });\n  }\n}\nfunction parse(html) {\n  const result = [];\n  let current = undefined;\n  let level = -1;\n  const arr = [];\n  const byTag = {};\n  html.replace(tagRE, (tag, index) => {\n    const isOpen = tag.charAt(1) !== '/';\n    const isComment = tag.slice(0, 4) === '<!--';\n    const start = index + tag.length;\n    const nextChar = html.charAt(start);\n    let parent = undefined;\n    if (isOpen && !isComment) {\n      level++;\n      current = parseTag(tag);\n      if (!current.voidElement && nextChar && nextChar !== '<') {\n        pushTextNode(current.children, html, start);\n      }\n      byTag[current.tagName] = current;\n      if (level === 0) {\n        result.push(current);\n      }\n      parent = arr[level - 1];\n      if (parent) {\n        parent.children.push(current);\n      }\n      arr[level] = current;\n    }\n    if (isComment) {\n      if (level < 0) {\n        pushCommentNode(result, tag);\n      } else {\n        pushCommentNode(arr[level].children, tag);\n      }\n    }\n    if (isComment || !isOpen || current.voidElement) {\n      if (!isComment) {\n        level--;\n      }\n      if (nextChar !== '<' && nextChar) {\n        parent = level === -1 ? result : arr[level].children;\n        pushTextNode(parent, html, start);\n      }\n    }\n  });\n  return result;\n}\nfunction attrString(attrs) {\n  const buff = [];\n  for (const attr of attrs) {\n    buff.push(attr.name + '=\"' + attr.value.replace(/\"/g, '&quot;') + '\"');\n  }\n  if (!buff.length) {\n    return '';\n  }\n  return ' ' + buff.join(' ');\n}\nfunction stringifier(buff, doc) {\n  switch (doc.type) {\n    case 'text':\n      return buff + doc.content;\n    case 'tag':\n      buff += '<' + doc.name + (doc.attrs ? attrString(doc.attrs) : '') + (doc.voidElement ? '/>' : '>');\n      if (doc.voidElement) {\n        return buff;\n      }\n      return buff + doc.children.reduce(stringifier, '') + '</' + doc.name + '>';\n    case 'comment':\n      return buff += '<!--' + doc.content + '-->';\n  }\n}\nfunction stringify(doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringifier('', rootEl);\n  }, '');\n}\nconst cache = new Map();\nconst VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst spaces = \" \\\\f\\\\n\\\\r\\\\t\";\nconst almostEverything = \"[^\" + spaces + \"\\\\/>\\\"'=]+\";\nconst attrName = \"[ \" + spaces + \"]+(?:use:<!--#-->|\" + almostEverything + ')';\nconst tagName = \"<([A-Za-z$#]+[A-Za-z0-9:_-]*)((?:\";\nconst attrPartials = \"(?:\\\\s*=\\\\s*(?:'[^']*?'|\\\"[^\\\"]*?\\\"|\\\\([^)]*?\\\\)|<[^>]*?>|\" + almostEverything + \"))?)\";\nconst attrSeeker = new RegExp(tagName + attrName + attrPartials + \"+)([ \" + spaces + \"]*/?>)\", \"g\");\nconst findAttributes = new RegExp(\"(\" + attrName + \"\\\\s*=\\\\s*)(<!--#-->|['\\\"(]([\\\\w\\\\s]*<!--#-->[\\\\w\\\\s]*)*['\\\")])\", \"gi\");\nconst selfClosing = new RegExp(tagName + attrName + attrPartials + \"*)([ \" + spaces + \"]*/>)\", \"g\");\nconst marker = \"<!--#-->\";\nconst reservedNameSpaces = new Set([\"class\", \"on\", \"oncapture\", \"style\", \"use\", \"prop\", \"attr\"]);\nfunction attrReplacer($0, $1, $2, $3) {\n  return \"<\" + $1 + $2.replace(findAttributes, replaceAttributes) + $3;\n}\nfunction replaceAttributes($0, $1, $2) {\n  return $1.replace(/<!--#-->/g, \"###\") + ($2[0] === '\"' || $2[0] === \"'\" ? $2.replace(/<!--#-->/g, \"###\") : '\"###\"');\n}\nfunction fullClosing($0, $1, $2) {\n  return VOID_ELEMENTS.test($1) ? $0 : \"<\" + $1 + $2 + \"></\" + $1 + \">\";\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction parseDirective(name, value, tag, options) {\n  if (name === 'use:###' && value === '###') {\n    const count = options.counter++;\n    options.exprs.push(`typeof exprs[${count}] === \"function\" ? r.use(exprs[${count}], ${tag}, exprs[${options.counter++}]) : (()=>{throw new Error(\"use:### must be a function\")})()`);\n  } else {\n    throw new Error(`Not support syntax ${name} must be use:{function}`);\n  }\n}\nfunction createHTML(r, {\n  delegateEvents = true,\n  functionBuilder = (...args) => new Function(...args)\n} = {}) {\n  let uuid = 1;\n  r.wrapProps = props => {\n    const d = Object.getOwnPropertyDescriptors(props);\n    for (const k in d) {\n      if (typeof d[k].value === \"function\" && !d[k].value.length) r.dynamicProperty(props, k);\n    }\n    return props;\n  };\n  function createTemplate(statics, opt) {\n    let i = 0,\n      markup = \"\";\n    for (; i < statics.length - 1; i++) {\n      markup = markup + statics[i] + \"<!--#-->\";\n    }\n    markup = markup + statics[i];\n    const replaceList = [[selfClosing, fullClosing], [/<(<!--#-->)/g, \"<###\"], [/\\.\\.\\.(<!--#-->)/g, \"###\"], [attrSeeker, attrReplacer], [/>\\n+\\s*/g, \">\"], [/\\n+\\s*</g, \"<\"], [/\\s+</g, \" <\"], [/>\\s+/g, \"> \"]];\n    markup = replaceList.reduce((acc, x) => {\n      return acc.replace(x[0], x[1]);\n    }, markup);\n    const pars = parse(markup);\n    const [html, code] = parseTemplate(pars, opt.funcBuilder),\n      templates = [];\n    for (let i = 0; i < html.length; i++) {\n      templates.push(document.createElement(\"template\"));\n      templates[i].innerHTML = html[i];\n      const nomarkers = templates[i].content.querySelectorAll(\"script,style\");\n      for (let j = 0; j < nomarkers.length; j++) {\n        const d = nomarkers[j].firstChild?.data || \"\";\n        if (d.indexOf(marker) > -1) {\n          const parts = d.split(marker).reduce((memo, p, i) => {\n            i && memo.push(\"\");\n            memo.push(p);\n            return memo;\n          }, []);\n          nomarkers[i].firstChild.replaceWith(...parts);\n        }\n      }\n    }\n    templates[0].create = code;\n    cache.set(statics, templates);\n    return templates;\n  }\n  function parseKeyValue(node, tag, name, value, isSVG, isCE, options) {\n    let expr = value === \"###\" ? `!doNotWrap ? exprs[${options.counter}]() : exprs[${options.counter++}]` : value.split(\"###\").map((v, i) => i ? ` + (typeof exprs[${options.counter}] === \"function\" ? exprs[${options.counter}]() : exprs[${options.counter++}]) + \"${v}\"` : `\"${v}\"`).join(\"\"),\n      parts,\n      namespace;\n    if ((parts = name.split(\":\")) && parts[1] && reservedNameSpaces.has(parts[0])) {\n      name = parts[1];\n      namespace = parts[0];\n    }\n    const isChildProp = r.ChildProperties.has(name);\n    const isProp = r.Properties.has(name);\n    if (name === \"style\") {\n      const prev = `_$v${uuid++}`;\n      options.decl.push(`${prev}={}`);\n      options.exprs.push(`r.style(${tag},${expr},${prev})`);\n    } else if (name === \"classList\") {\n      const prev = `_$v${uuid++}`;\n      options.decl.push(`${prev}={}`);\n      options.exprs.push(`r.classList(${tag},${expr},${prev})`);\n    } else if (namespace !== \"attr\" && (isChildProp || !isSVG && (r.getPropAlias(name, node.name.toUpperCase()) || isProp) || isCE || namespace === \"prop\")) {\n      if (isCE && !isChildProp && !isProp && namespace !== \"prop\") name = toPropertyName(name);\n      options.exprs.push(`${tag}.${r.getPropAlias(name, node.name.toUpperCase()) || name} = ${expr}`);\n    } else {\n      const ns = isSVG && name.indexOf(\":\") > -1 && r.SVGNamespace[name.split(\":\")[0]];\n      if (ns) options.exprs.push(`r.setAttributeNS(${tag},\"${ns}\",\"${name}\",${expr})`);else options.exprs.push(`r.setAttribute(${tag},\"${r.Aliases[name] || name}\",${expr})`);\n    }\n  }\n  function parseAttribute(node, tag, name, value, isSVG, isCE, options) {\n    if (name.slice(0, 2) === \"on\") {\n      if (!name.includes(\":\")) {\n        const lc = name.slice(2).toLowerCase();\n        const delegate = delegateEvents && r.DelegatedEvents.has(lc);\n        options.exprs.push(`r.addEventListener(${tag},\"${lc}\",exprs[${options.counter++}],${delegate})`);\n        delegate && options.delegatedEvents.add(lc);\n      } else {\n        let capture = name.startsWith(\"oncapture:\");\n        options.exprs.push(`${tag}.addEventListener(\"${name.slice(capture ? 10 : 3)}\",exprs[${options.counter++}]${capture ? \",true\" : \"\"})`);\n      }\n    } else if (name === \"ref\") {\n      options.exprs.push(`exprs[${options.counter++}](${tag})`);\n    } else {\n      const childOptions = Object.assign({}, options, {\n          exprs: []\n        }),\n        count = options.counter;\n      parseKeyValue(node, tag, name, value, isSVG, isCE, childOptions);\n      options.decl.push(`_fn${count} = (${value === \"###\" ? \"doNotWrap\" : \"\"}) => {\\n${childOptions.exprs.join(\";\\n\")};\\n}`);\n      if (value === \"###\") {\n        options.exprs.push(`typeof exprs[${count}] === \"function\" ? r.effect(_fn${count}) : _fn${count}(true)`);\n      } else {\n        let check = \"\";\n        for (let i = count; i < childOptions.counter; i++) {\n          i !== count && (check += \" || \");\n          check += `typeof exprs[${i}] === \"function\"`;\n        }\n        options.exprs.push(check + ` ? r.effect(_fn${count}) : _fn${count}()`);\n      }\n      options.counter = childOptions.counter;\n      options.wrap = false;\n    }\n  }\n  function processChildren(node, options) {\n    const childOptions = Object.assign({}, options, {\n      first: true,\n      multi: false,\n      parent: options.path\n    });\n    if (node.children.length > 1) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (child.type === \"comment\" && child.content === \"#\" || child.type === \"tag\" && child.name === \"###\") {\n          childOptions.multi = true;\n          break;\n        }\n      }\n    }\n    let i = 0;\n    while (i < node.children.length) {\n      const child = node.children[i];\n      if (child.name === \"###\") {\n        if (childOptions.multi) {\n          node.children[i] = {\n            type: \"comment\",\n            content: \"#\"\n          };\n          i++;\n        } else node.children.splice(i, 1);\n        processComponent(child, childOptions);\n        continue;\n      }\n      parseNode(child, childOptions);\n      if (!childOptions.multi && child.type === \"comment\" && child.content === \"#\") node.children.splice(i, 1);else i++;\n    }\n    options.counter = childOptions.counter;\n    options.templateId = childOptions.templateId;\n    options.hasCustomElement = options.hasCustomElement || childOptions.hasCustomElement;\n    options.isImportNode = options.isImportNode || childOptions.isImportNode;\n  }\n  function processComponentProps(propGroups) {\n    let result = [];\n    for (const props of propGroups) {\n      if (Array.isArray(props)) {\n        if (!props.length) continue;\n        result.push(`r.wrapProps({${props.join(\",\") || \"\"}})`);\n      } else result.push(props);\n    }\n    return result.length > 1 ? `r.mergeProps(${result.join(\",\")})` : result[0];\n  }\n  function processComponent(node, options) {\n    let props = [];\n    const keys = Object.keys(node.attrs),\n      propGroups = [props],\n      componentIdentifier = options.counter++;\n    for (let i = 0; i < keys.length; i++) {\n      const {\n        type,\n        name,\n        value\n      } = node.attrs[i];\n      if (type === 'attr') {\n        if (name === \"###\") {\n          propGroups.push(`exprs[${options.counter++}]`);\n          propGroups.push(props = []);\n        } else if (value === \"###\") {\n          props.push(`\"${name}\": exprs[${options.counter++}]`);\n        } else props.push(`\"${name}\": \"${value}\"`);\n      } else if (type === 'directive') {\n        const tag = `_$el${uuid++}`;\n        const topDecl = !options.decl.length;\n        options.decl.push(topDecl ? \"\" : `${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n        parseDirective(name, value, tag, options);\n      }\n    }\n    if (node.children.length === 1 && node.children[0].type === \"comment\" && node.children[0].content === \"#\") {\n      props.push(`children: () => exprs[${options.counter++}]`);\n    } else if (node.children.length) {\n      const children = {\n          type: \"fragment\",\n          children: node.children\n        },\n        childOptions = Object.assign({}, options, {\n          first: true,\n          decl: [],\n          exprs: [],\n          parent: false\n        });\n      parseNode(children, childOptions);\n      props.push(`children: () => { ${childOptions.exprs.join(\";\\n\")}}`);\n      options.templateId = childOptions.templateId;\n      options.counter = childOptions.counter;\n    }\n    let tag;\n    if (options.multi) {\n      tag = `_$el${uuid++}`;\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n    }\n    if (options.parent) options.exprs.push(`r.insert(${options.parent}, r.createComponent(exprs[${componentIdentifier}],${processComponentProps(propGroups)})${tag ? `, ${tag}` : \"\"})`);else options.exprs.push(`${options.fragment ? \"\" : \"return \"}r.createComponent(exprs[${componentIdentifier}],${processComponentProps(propGroups)})`);\n    options.path = tag;\n    options.first = false;\n  }\n  function parseNode(node, options) {\n    if (node.type === \"fragment\") {\n      const parts = [];\n      node.children.forEach(child => {\n        if (child.type === \"tag\") {\n          if (child.name === \"###\") {\n            const childOptions = Object.assign({}, options, {\n              first: true,\n              fragment: true,\n              decl: [],\n              exprs: []\n            });\n            processComponent(child, childOptions);\n            parts.push(childOptions.exprs[0]);\n            options.counter = childOptions.counter;\n            options.templateId = childOptions.templateId;\n            return;\n          }\n          options.templateId++;\n          const id = uuid;\n          const childOptions = Object.assign({}, options, {\n            first: true,\n            decl: [],\n            exprs: []\n          });\n          options.templateNodes.push([child]);\n          parseNode(child, childOptions);\n          parts.push(`function() { ${childOptions.decl.join(\",\\n\") + \";\\n\" + childOptions.exprs.join(\";\\n\") + `;\\nreturn _$el${id};\\n`}}()`);\n          options.counter = childOptions.counter;\n          options.templateId = childOptions.templateId;\n        } else if (child.type === \"text\") {\n          parts.push(`\"${child.content}\"`);\n        } else if (child.type === \"comment\") {\n          if (child.content === \"#\") parts.push(`exprs[${options.counter++}]`);else if (child.content) {\n            for (let i = 0; i < child.content.split(\"###\").length - 1; i++) {\n              parts.push(`exprs[${options.counter++}]`);\n            }\n          }\n        }\n      });\n      options.exprs.push(`return [${parts.join(\", \\n\")}]`);\n    } else if (node.type === \"tag\") {\n      const tag = `_$el${uuid++}`;\n      const topDecl = !options.decl.length;\n      const templateId = options.templateId;\n      options.decl.push(topDecl ? \"\" : `${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n      const isSVG = r.SVGElements.has(node.name);\n      const isCE = node.name.includes(\"-\") || node.attrs.some(e => e.name === \"is\");\n      options.hasCustomElement = isCE;\n      options.isImportNode = (node.name === 'img' || node.name === 'iframe') && node.attrs.some(e => e.name === \"loading\" && e.value === 'lazy');\n      if (node.attrs.some(e => e.name === \"###\")) {\n        const spreadArgs = [];\n        let current = \"\";\n        const newAttrs = [];\n        for (let i = 0; i < node.attrs.length; i++) {\n          const {\n            type,\n            name,\n            value\n          } = node.attrs[i];\n          if (type === 'attr') {\n            if (value.includes(\"###\")) {\n              let count = options.counter++;\n              current += `${name}: ${name !== \"ref\" ? `typeof exprs[${count}] === \"function\" ? exprs[${count}]() : ` : \"\"}exprs[${count}],`;\n            } else if (name === \"###\") {\n              if (current.length) {\n                spreadArgs.push(`()=>({${current}})`);\n                current = \"\";\n              }\n              spreadArgs.push(`exprs[${options.counter++}]`);\n            } else {\n              newAttrs.push(node.attrs[i]);\n            }\n          } else if (type === 'directive') {\n            parseDirective(name, value, tag, options);\n          }\n        }\n        node.attrs = newAttrs;\n        if (current.length) {\n          spreadArgs.push(`()=>({${current}})`);\n        }\n        options.exprs.push(`r.spread(${tag},${spreadArgs.length === 1 ? `typeof ${spreadArgs[0]} === \"function\" ? r.mergeProps(${spreadArgs[0]}) : ${spreadArgs[0]}` : `r.mergeProps(${spreadArgs.join(\",\")})`},${isSVG},${!!node.children.length})`);\n      } else {\n        for (let i = 0; i < node.attrs.length; i++) {\n          const {\n            type,\n            name,\n            value\n          } = node.attrs[i];\n          if (type === 'directive') {\n            parseDirective(name, value, tag, options);\n            node.attrs.splice(i, 1);\n            i--;\n          } else if (type === \"attr\") {\n            if (value.includes(\"###\")) {\n              node.attrs.splice(i, 1);\n              i--;\n              parseAttribute(node, tag, name, value, isSVG, isCE, options);\n            }\n          }\n        }\n      }\n      options.path = tag;\n      options.first = false;\n      processChildren(node, options);\n      if (topDecl) {\n        options.decl[0] = options.hasCustomElement || options.isImportNode ? `const ${tag} = r.untrack(() => document.importNode(tmpls[${templateId}].content.firstChild, true))` : `const ${tag} = tmpls[${templateId}].content.firstChild.cloneNode(true)`;\n      }\n    } else if (node.type === \"text\") {\n      const tag = `_$el${uuid++}`;\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n      options.path = tag;\n      options.first = false;\n    } else if (node.type === \"comment\") {\n      const tag = `_$el${uuid++}`;\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n      if (node.content === \"#\") {\n        if (options.multi) {\n          options.exprs.push(`r.insert(${options.parent}, exprs[${options.counter++}], ${tag})`);\n        } else options.exprs.push(`r.insert(${options.parent}, exprs[${options.counter++}])`);\n      }\n      options.path = tag;\n      options.first = false;\n    }\n  }\n  function parseTemplate(nodes, funcBuilder) {\n    const options = {\n        path: \"\",\n        decl: [],\n        exprs: [],\n        delegatedEvents: new Set(),\n        counter: 0,\n        first: true,\n        multi: false,\n        templateId: 0,\n        templateNodes: []\n      },\n      id = uuid,\n      origNodes = nodes;\n    let toplevel;\n    if (nodes.length > 1) {\n      nodes = [{\n        type: \"fragment\",\n        children: nodes\n      }];\n    }\n    if (nodes[0].name === \"###\") {\n      toplevel = true;\n      processComponent(nodes[0], options);\n    } else parseNode(nodes[0], options);\n    r.delegateEvents(Array.from(options.delegatedEvents));\n    const templateNodes = [origNodes].concat(options.templateNodes);\n    return [templateNodes.map(t => stringify(t)), funcBuilder(\"tmpls\", \"exprs\", \"r\", options.decl.join(\",\\n\") + \";\\n\" + options.exprs.join(\";\\n\") + (toplevel ? \"\" : `;\\nreturn _$el${id};\\n`))];\n  }\n  function html(statics, ...args) {\n    const templates = cache.get(statics) || createTemplate(statics, {\n      funcBuilder: functionBuilder\n    });\n    return templates[0].create(templates, args, r);\n  }\n  return html;\n}\n\nconst html = createHTML({\n  effect,\n  style,\n  insert,\n  untrack,\n  spread,\n  createComponent,\n  delegateEvents,\n  classList,\n  mergeProps,\n  dynamicProperty,\n  setAttribute,\n  setAttributeNS,\n  addEventListener,\n  Aliases,\n  getPropAlias,\n  Properties,\n  ChildProperties,\n  DelegatedEvents,\n  SVGElements,\n  SVGNamespace\n});\n\nexport { html as default };\n"],"mappings":"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"}